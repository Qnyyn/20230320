## 科林明伦三阶段笔记

[TOC]



### 1.静态库动态库

![](D:\科林明伦三阶段\三阶段笔记内容截图\1.png)

库是在链接期的，分为静态链接和动态链接

**静态库缺点优点**

![](D:\科林明伦三阶段\三阶段笔记内容截图\2.png)

缺点两个，优点一个：
缺点：1.空间浪费，多个程序同时依赖一个静态库就会在内存拷贝多份造成空间浪费。
2.更新麻烦，静态库更新了需要对库重新编译，发布给用户，用户需要整个程序重新下载

优点：使用速度快，因为不需要像dll文件那样先找索引文件在通过索引找里面的动态库，所以速度更快

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\3.png" alt="3" style="zoom:60%;" />

动态库：优点两个，缺点一个，和静态库反着记就行

**静态库的使用**

```c++
#include<iostream>
#include"./include/pch.h"
using namespace std;

#pragma comment(lib,"./lib/StaticLib.lib")
//静态库使用方法：
//1.把头文件拷贝到当前项目中，在文件中包含
//2.把库文件拷贝到当前项目中，在文件中添加依赖

int main() {
	int c = add(2, 5);
	cout << "2 + 5 = " << c << endl;//7

	system("pause");

	return 0;
}
```

动态库的使用

```c++
int add(int a, int b);

_declspec (dllexport) int sub(int a, int b);//声明导出：_declspec (dllexport)，只有声明导出的函数才会被写入索引文件
```

```c++
#include<iostream>
#include"./include/pch.h"
using namespace std;

#pragma comment(lib,"./lib/DLL.lib")

//动态库的使用方法：
//1、把头文件拷贝到当前项目中，在文件中包含
//2、把索引文件拷贝到当前项目中，在文件中添加依赖
//3、把动态库dll拷贝到exe同文件目录下

int main() {
	//? 由于add函数没声明导出所以不能使用
	//int c = add(2, 5);
	//cout << "2 + 5 = " << c << endl;

	int c = sub(10, 2);
	cout << "10-2 = " << c << endl;//8

	system("pause");

	return 0;
}
```

```c++
//原理：
//静态库在链接期，把库文件拷贝到可执行文件中
//动态库在链接期，只把索引文件拷贝到可执行文件中，在运行的时候才调用动态库
```

### 2.网络基本模型

![](D:\科林明伦三阶段\三阶段笔记内容截图\4.png)

#### 2.1 socket(套接字):

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\b1.png" style="zoom:60%;" />

#### 2.2 CS/BS架构

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\b2.png" style="zoom:60%;" />

CS:服务端客户端固定，协议不固定

BS:客户端不固定，协议固定

#### 2.3 数据包在传输过程中的变化

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\b3.png" style="zoom:60%;" />

#### 2.4 单播组播和广播

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\b4.png" style="zoom:60%;" />

广播不关心你是谁只关心范围，比如一个学校发广播，你离开学校了你就收不到了

组播关心你是谁，你只要在我要发的这个群组里你就能收到不管你在哪，不关心你的范围

**直接广播的主机号全为1，而有限广播的三十二位不管是网络号还是主机号全为一，对应255.255.255.255**

**有限广播地址和直接广播地址的区别**：在于，有限广播地址不需要知道网络号，直接在本网段内进行广播，而直接广播需要知道网段，在指定网段下进行广播

#### 2.5 ARP协议

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\b5.png" style="zoom:60%;" />

#### 2.6 ARP 代理

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\b6.png" style="zoom:60%;" />

#### 2.7 免费ARP

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\b7.png" style="zoom:60%;" />

过程：在主机开机配置时，发送一个目的ip为自己ip的ARP请求报文

作用：1.确认本地网络里有没有与自己相同的ip地址的主机，有就返回错误报文

2.告诉广播域自己的ip地址和mac地址，相当于发传单，若接收主机的ARP缓存里有发送源主机的ip-mac对，则更新，没有就缓存

#### 2.8 子网划分常见问题

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\b8.png" style="zoom:60%;" />

#### **2.9 IP地址分类**

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\b11.png" style="zoom:60%;" />

### 3.**UDP和TCP服务端和客户端的代码流程**（CS架构）

![](D:\科林明伦三阶段\三阶段笔记内容截图\5.png)

#### 3.1.UDP服务端创建步骤：

加载库，创建套接字，绑定ip和端口，循环接受消息和发送消息，关闭套接字，卸载库

```c++
// 加载库
//需要这俩头
#include<winsock2.h>
#pragma comment(lib,"Ws2_32.lib")

WORD wVersion = MAKEWORD(2, 2);
WSAData data;
int err = WSAStartup(wVersion,&data);//主要是这个WSAStartup函数，两个参数，第一个套的是一个WORD类型的变量，意思是版本号，用makeword创建第二个要的是LPWSADATA，这个东西是个结构体类型的指针，也就是说传一个结构体的地址，类型是WSAData，函数的返回值是一个int，用来进行错误判断
if (err != 0) {//创建成功err的值为0
    cout << "WSAStartup error:" << err << endl;
    return -1;
}
if (/*找到data这个结构体里面的版本号信息的低字节，看看是不是2，有一个不是2说明版本都错了*/LOBYTE(data.wVersion) != 2 || HIBYTE(data.wVersion) != 2) {
    cout << "WSAStartup version error" << endl;
    //版本错了但是可能加载库了，所以我们需要卸载库
    WSACleanup();
    return -1;
}
else cout << "WSAStartup success" << endl;
```



```c++
	//? 创建套接字
	SOCKET sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
	//socket函数用于创建套接字，返回值为SOCKET，参数第一个是协议族，ipv4，第二个是udp协议还是tcp协议，第三个也是一样
	if (sock == INVALID_SOCKET) {//INVALID_SOCKET就是socket创建错误，就要卸载库
		cout << "socket error:" << WSAGetLastError() << endl;
		WSACleanup();
		return -1;
	}
	else {
		cout << "socket success" << endl;
	}
```



```c++
//? 绑定ip和端口号:在操作系统注册当前进程可以接收数据的端口和ip地址，UDP一般只有服务端需要绑定ip
	struct sockaddr_in addrServer;
	addrServer.sin_family = AF_INET;//ipv4
	addrServer.sin_port = htons(67781);				//? htons转换成网络字节序
	addrServer.sin_addr.S_un.S_addr = INADDR_ANY;//? 绑定任意网卡

	err = bind(sock, (sockaddr*)&addrServer,sizeof(addrServer));//一切基于bind这个函数，参数第一个为socket，第二个是一个服务端的结构体类型，需要进行初始化去绑定端口和网卡，才有了上面四段，最后为长度，返回值为int
	
	if (err == SOCKET_ERROR) {
		cout << "bind error" << WSAGetLastError() << endl;
		closesocket(sock);

		WSACleanup();
		return -1;
	}
	else {
		cout << "bind success" << endl;
	}

```



```c++

	int nRecvNum = 0;
	int nSendNum = 0;
	char recvbuf[1024] = "";
	char sendbuf[1024] = "";
	struct sockaddr_in addrClient;
	int addrClientSize = sizeof(addrClient);
	cout << "recvSize :" << recvSize <<" " << "sendSize :" << sendSize << endl;

while (true) {
		// 循环接收消息 
		nRecvNum = recvfrom(sock, recvbuf,sizeof(recvbuf),0, (sockaddr*)&addrClient, &addrClientSize);//recvfrom接收数据，因为是服务端得先接收。第二个参数是接收到的字符串，所以要定义char recvbuf[1024]，然后长度，然后默认，然后是从哪接收的消息，那就是client这个结构体，所以定义struct sockaddr_in addrClient，返回值是一个int，是你接收到的字节长度
		if (nRecvNum > 0) {
			//? 打印收到的数据
			//? 192.168.3.82--十进制四等分字符串类型ip地址:inet_addr  (ip 变 ulong)
			//? ulong类型ip地址：inet_ntoa   (ulong 变 ip)
			cout << "ip :" << inet_ntoa(addrClient.sin_addr) << ":" << recvbuf << endl;
		}
		else if (nRecvNum == 0) {//等于0的时候说明没接收到
			cout << "connect closed" << endl;
			break;
		}
		else {//都不是说明错了
			cout << "recv error" << WSAGetLastError() << endl;
		}
    
    
    	//? 循环发送消息 
		gets_s(sendbuf);//使用gets_s来把你的要发送的字符串传到你的输入框里缓存
		nSendNum = sendto(sock, sendbuf,sizeof(sendbuf),0,(sockaddr*)&addrClient,addrClientSize);
    //使用sendto发送数据，第二个是发送的字符串数组char sendbuf[1024]，然后长度，默认，然后就是发送给哪个结构体，那就是客户端结构体，然后长度，返回值是一个int，如果是SOCKET_ERROR说明没发出去
		if (nSendNum == SOCKET_ERROR) {
			cout << "send error" << WSAGetLastError() << endl;
			break;
		}
		else {
			cout << "ip :" << inet_ntoa(addrServer.sin_addr) << ":" << sendbuf << endl;
		}
    
    
	}
```

```c++
	// 最后卸载套接字
	closesocket(sock);

	// 和卸载库
	WSACleanup();
```

#### 3.2 UDP客户端创建步骤

加载库，创建套接字，循环接受消息和发送消息，关闭套接字，卸载库（除了没有绑定ip和端口，其他都一样）

#### 3.3TCP服务端创建步骤

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\25.png" style="zoom:60%;" />

```c++
#include<iostream>
#include<winsock2.h>
#pragma comment(lib,"Ws2_32.lib")
using namespace std;


int main() {
	// 加载库
	WORD wVersion = MAKEWORD(2, 2);
	WSAData data;
	int err = WSAStartup(wVersion, &data);
	if (err != 0) {
		cout << "WSAStartup error:" << err << endl;
		return -1;
	}
	if (LOBYTE(data.wVersion) != 2 || HIBYTE(data.wVersion) != 2) {
		cout << "WSAStartup version error" << endl;
		WSACleanup();
		return -1;
	}
	else cout << "WSAStartup success" << endl;

	//创建套接字
	SOCKET sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);//此处有不同，tcp用的是字节流所以是STREAM
	if (sock == INVALID_SOCKET) {
		cout << "socket error:" << WSAGetLastError() << endl;
		WSACleanup();
		return -1;
	}
	else {
		cout << "socket success" << endl;
	}

	//绑定ip地址和端口号
	struct sockaddr_in addrServer;
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(67781);				
	addrServer.sin_addr.S_un.S_addr = INADDR_ANY;

	err = bind(sock, (sockaddr*)&addrServer, sizeof(addrServer));
	if (err == SOCKET_ERROR) {
		cout << "bind error" << WSAGetLastError() << endl;
		closesocket(sock);
		WSACleanup();
		return -1;
	}
	else {
		cout << "bind success" << endl;
	}

	//监听，listen函数监听，后面的参数10可以随便给
	err = listen(sock, 10);
	if (err == SOCKET_ERROR) {
		cout << "listen error" << WSAGetLastError() << endl;
		closesocket(sock);
		WSACleanup();
		return -1;
	}
	else {
		cout << "listen success" << endl;
	}


	struct sockaddr_in addrClient;
	int addrClientSize = sizeof(addrClient);
	int nRecvNum = 0;
	int nSendNum = 0;
	char recvbuf[1024] = "";
	char sendbuf[1024] = "";
	while (true) {
		//循环接收连接
		SOCKET sockWaiter = accept(sock, (sockaddr*)&addrClient, &addrClientSize);//要返回一个socket，因为之前的socket又绑定ip又监听，干的活太多了，需要另外的socket
		if (sockWaiter == INVALID_SOCKET) {
			cout << "accept error" << WSAGetLastError() << endl;
			break;
		}
		else {
			//连接成功，打印客户端ip
			cout << "ip: " << inet_ntoa(addrClient.sin_addr) << endl;
		}
		while (true) {
			//循环接收数据
			nRecvNum = recv(sockWaiter, recvbuf,sizeof(recvbuf),0);
			if (nRecvNum > 0) {
				
				cout << "客户端说 :" << recvbuf << endl;
			}
			else if (nRecvNum == 0) {
				cout << "connect closed" << endl;
				break;
			}
			else {
				cout << "recv error" << WSAGetLastError() << endl;
			}
			//循环发送数据
			gets_s(sendbuf);
			nSendNum = send(sockWaiter, sendbuf,sizeof(sendbuf),0);
			if (nSendNum == SOCKET_ERROR) {
				cout << "send error" << WSAGetLastError() << endl;
				break;
			}
			else {
				cout << "服务端发送 :" << sendbuf << endl;
			}

			
		}

		closesocket(sockWaiter);

	}


	//关闭套接字
	closesocket(sock);

	//卸载库
	WSACleanup();
	return 0;
}
```



#### 3.4TCP客户端创建步骤

加载库，创建套接字，循环发送连接，循环接受消息和发送消息，关闭套接字，卸载库

```c++
	// 加载库
	WORD wVersion = MAKEWORD(2, 2);
	WSAData data;
	int err = WSAStartup(wVersion, &data);
	if (err != 0) {
		cout << "WSAStartup error:" << err << endl;
		return -1;
	}
	if (LOBYTE(data.wVersion) != 2 || HIBYTE(data.wVersion) != 2) {
		cout << "WSAStartup version error" << endl;
		WSACleanup();
		return -1;
	}
	else cout << "WSAStartup success" << endl;
```



```c++
//创建套接字
	SOCKET sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sock == INVALID_SOCKET) {
		cout << "socket error:" << WSAGetLastError() << endl;
		WSACleanup();
		return -1;
	}
	else {
		cout << "socket success" << endl;
	}
```



```c++
//循环发送连接需要做的初始化
	struct sockaddr_in addrServer;//需要服务端的信息，所以初始化服务端
	int addrServerSize = sizeof(addrServer);
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(67781);
	addrServer.sin_addr.S_un.S_addr = inet_addr("10.71.172.231");//ip->ulong
```



```c++
//循环发送连接
while (true) {
		//循环发送连接，由于和server端不一样，服务端的sock需要去绑定ip和端口号，不能在用于发数据，而是在accept函数的返回值返回了一个新的socket，用于发送数据和接收数据
    
		err = connect(sock, (sockaddr*)&addrServer, addrServerSize);//connect的返回值是个int，和accept的SOCKET不一样，参数二，连接，连接谁，服务端，，然后服务端的大小
		if (err == SOCKET_ERROR) {
			cout << "connect error" << WSAGetLastError() << endl;
			break;
		}
		else {
			//连接成功，打印服务端ip
			cout << "ip: " << inet_ntoa(addrServer.sin_addr) << endl;
		}
		while (true) {	
			//循环发送数据

			//循环接收数据
		}

	}
```



```c++
//发送数据和接收数据需要的初始化
	int nRecvNum = 0;
	int nSendNum = 0;
	char recvbuf[1024] = "";
	char sendbuf[1024] = "";
```



```c++
//循环发送数据
while (true) {
		//循环发送连接
		while (true) {
			
			//循环发送数据
			gets_s(sendbuf);
			nSendNum = send(sock, sendbuf, sizeof(sendbuf), 0);//send和recv 比  sendto 和 recvfrom少两个参数，send是少了发给谁和谁的大小，因为已经连接过了，不需要再指定发给谁，recv少了从谁那里接收和大小
			if (nSendNum == SOCKET_ERROR) {//int型返回值错误都是SOCKET_ERROR
				cout << "send error" << WSAGetLastError() << endl;
				break;
			}
			else {
				cout << "客户端发送 : "<< sendbuf << endl;
			}

			

			//循环接收数据


		}

	}
```



```c++
while (true) {
		//循环发送连接
		while (true) {
			
			//循环发送数据
			

			//循环接收数据
			nRecvNum = recv(sock, recvbuf, sizeof(recvbuf), 0);
			if (nRecvNum > 0) {
				cout << "服务端说 : "<< recvbuf << endl;
			}
			else if (nRecvNum == 0) {
				cout << "connect closed" << endl;
				break;
			}
			else {
				cout << "recv error" << WSAGetLastError() << endl;
			}


		}


	}
```



```c++
	//关闭套接字
	closesocket(sock);

	//卸载库
	WSACleanup();
```

#### 3.5 阻塞和非阻塞

```c++
	// 阻塞和非阻塞
	// 阻塞:老王烧水，把水壶放在炉子上，就在旁边等着，这个期间什么也不干，直到水开结束
	// 非阻塞:老王烧水，把水壶放在炉子上，就看电视去了，每隔一段时间回来看看水开没开，开了就结束，没开就再去看会电视
	// socket默认是阻塞的
	// 设置非阻塞条件
	u_long val = 1;//1是非阻塞
	ioctlsocket(sock, FIONBIO, &val);
```

#### 3.6发送缓冲区和接收缓冲区

```c++
	// 发送缓冲区和接收缓冲区
每创建一个socket ，操作系统就会为这个socket创建一个接收缓冲区和一个发送缓冲区
	// 接收时操作系统的内核有个接收缓冲区，当你需要接收数据时，从内核缓冲取拷贝到实际你的应用程序的缓冲区数组中
	// 发送时从应用程序缓冲区往内核发送缓冲区拷贝内容

	//发送的阻塞和非阻塞
	//发送阻塞:当发送缓冲区空间不足够大的时候，等到发送缓冲区空间足够大再发送剩下的数据应用程序自己处理
	//发送非阻塞:当发送缓冲区空间不足够大的时候，有多少空间就往里拷贝多少内容，剩下的内容自己处理
	int recvSize = 0;
	int sendSize = 0;
	int size = sizeof(int);
	//查看接收缓冲区大小和发送缓冲区大小
	getsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char*)&recvSize, &size);
	getsockopt(sock, SOL_SOCKET, SO_SNDBUF, (char*)&sendSize, &size);
	cout << "recvSize :" << recvSize <<" " << "sendSize :" << sendSize << endl;//65536 2的16次幂
```

#### 3.7 发送阻塞和非阻塞

```c++
//发送阻塞：发送缓冲区不够大的时候，等到空间足够大在发送
//发送非阻塞：发送缓冲区不够大的时候，有多少空间就拷贝多少内容，剩下的数据应用程序自己处理
```

#### 3.8 以太网的帧结构

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\b9.png" style="zoom:60%;" />

**MTU**：一个网络包的最大长度，一般为1500字节

**MSS**：一个网络包所能容纳的TCP数据的最大长度（在MTU的基础上去掉了ip头和tcp头，本质上就是数据的最大长度）

#### 3.9 IP协议格式

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\b10.png" style="zoom:67%;" />

### 4.TCP/IP协议

#### 4.1思维导图

![](D:\科林明伦三阶段\三阶段笔记内容截图\请假笔记.png)

#### 4.2 TCP报文头

![](D:\科林明伦三阶段\三阶段笔记内容截图\6.png)

1）**源端口和目的端口**：用于寻找发端和收端的应用程序。这两个值加上IP首部的源端IP和目的端IP唯一确定一个TCP连接；

2）**序号（Seq）**：标识从TCP发端向TCP收端发送的数据字节流，它标识在这个报文段中的第一个数据字节的序号。如果将字节流看作在两个应用程序间的单向流动，

则TCP用序号对每个字节进行计数。序号是32bit的无符号数，序号到达2的32次方减一后又从0开始。SYN标志消耗一个序号；

3）**确认序号（ACK）**：如果上次成功收到数据字节序号加一。只有ACK标志为1时确认序号才有效，ACK = Seq + 1；

4）**数据偏移**（首部长度）：标识该TCP头部有多少个32bit（4字节），4比特最大表示15，TCP头部最长为60字节；

5）**窗口**：TCP流量控制的手段，告诉对方，我的TCP接收端缓冲区还能容纳多少个字节，这样对方能控制发送数据的速度；

6）**校验和**：由发送端填充，接收端对TCP报文执行CRC算法，以检验TCP报文段是否损毁。不仅校验头部，还包括数据部分；

7）**紧急指针**：也称为紧急偏移。紧急指针是一个正的偏移量，和序号字段的值相加表示最后一个紧急指针的下一字节的序号。是相对于当前序号的偏移。紧急指针是发送端向接收端发送紧急数据的方法；

8）**六个标志位**:

```markdown
    a）URG：表示紧急指针是否有效；

    b）ACK：表示确认号是否有效，携带ACK标志的数据报文段为确认报文段；

    c）PSH：提示接收端的应用程序应该立即从TCP接受缓冲区中读走数据，为接受后数据腾出空间；

    d）RST：表示要求对方重新建立连接，携带RST标志位的TCP报文段称为复位报文段；

    e）SYN：  表示请求建立一个连接，携带SYN标志的TCP报文段称为同步报文段；

    f）FIN：通知对方本端要关闭了，带FIN标志的TCP报文段称为结束报文段；
```

9）TCP头部选项：头部选项是一个可变长的信息，这部分最多包含40个字节（前面20字节是固定的）

头部选项的实际运用:

```markdown
    a）最大报文传输段（Maxinum Segment Size——MSS，后续进行详解）

    b）窗口扩大选项（window scaling）

    c）选择确认选项（Selective Acknowledgements——SACK）

    d）NOP
```

#### 4.3 ACK确认机制

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\7.png" style="zoom:50%;" />

#### **4.4 超时重传**

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\8.png" style="zoom:50%;" />

#### 4.5 TCP传输协议

##### 4.5.1 三次握手

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\9.png" style="zoom: 67%;" />

关于三次握手的几个问题：

**问题1.为什么不是两次握手**：为了确保全双工模式，能确保有发的同时也有收

**问题2.为什么不是四次握手**：正常第二轮里，要先发ACK确认包，然后再发送SYN建立连接包，但是合并在一起了，就只需要进行三次握手

**问题3.第三轮的client发送ACK包的时候可以携带数据吗**：答案是可以，如果着急的话可以在第三轮的ACK确认的时候进行携带数据

第一次建立连接的SYN包的seq是随机产生的值，第二轮的ack确认的值是前一轮的seq+1，第三轮的seq就是SYN发送过来的seq的值+1，第三轮的ack就是前一轮的seq+1也就是y+1

##### 4.5.2 四次挥手

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\10.png" style="zoom: 67%;" />

关于四次挥手的几个问题：

**问题一：为什么被动方要在第二次发送ACK包的时候携带FIN标志，证明自己要断开连接了**：因为可能还有路上正在发送的数据，先发后到，需要等待被动方处理完数据之后再发送FIN报文

**问题二：要怎么知道最后一次主动方发送的ACK确认报文被动方接收到了**：如果被动方没有接收到的话会进行超时重传，如果主动方在2MSL（最大存活周期）的时间内一直发送确认包并且没有收到来自被动方的FIN报文说明被动方已经成功接收到了主动方发送的ACK包，已经断开连接不会再进行回复了。

#### 4.6 往返时延（RTT）

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\11.png" style="zoom:67%;" />

起决定性因素的是排队时间

#### 4.7 超时重传时间（RTO）

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\12.png" style="zoom:67%;" />

#### 4.8 TCP的流量控制（滑动窗口）

**接收端与发送端第一次交换窗口大小是在三次握手的第二次和第三次握手。**

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\13.png" style="zoom:67%;" />

##### **4.8.1窗口大小由哪一方决定？**

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\14.png" style="zoom:67%;" />

##### **4.8.2流量控制：端到端的控制**

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\15.png" style="zoom:60%;" />

#### 4.9 粘包问题

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\16.png" style="zoom:60%;" />

1、标志位的缺陷：用户的数据可能和设置的标志位重复，只有一个包的时候你设置标志位你就不知道什么时候结束

适合场景：用户输入的内容固定，不存在用户输入的数据都是程序员写好的，肯定不会重复

2、固定包大小的缺陷：包设的太大浪费空间，设的太小不够发

适用场景：服务器发送的数据大小比较固定的情况

3、先发数据长度再发数据包：浪费资源和时间，要一次发俩包

适用场景：通用

4、短连接：速度太慢了

适用情况：浏览网页

#### 4.10 心跳机制

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\17.png" style="zoom:67%;" />

使用场景：长连接并且长时间无数据往来

客户端每隔一段时间给服务端发个消息，服务端也给客户端回个消息证明自己活着呢

#### 4.11 Nagle算法

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\18.png" style="zoom:67%;" />

#### 4.12 拥塞控制

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\19.png" alt="19" style="zoom:60%;" />

##### 4.12.1 四种拥塞控制算法

1.慢开始

2.拥塞避免

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\20.png" style="zoom:60%;" />



<img src="D:\科林明伦三阶段\三阶段笔记内容截图\21.png" style="zoom:60%;" />

3.快重传

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\22.png" style="zoom:60%;" />

4.快恢复

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\23.png" style="zoom:60%;" />

快恢复的条件：收到三个重复的ACK，特点是拥塞窗口变为原来的一半（本图原来出现超时重传的时间点是12，所以一半是6）+3 = 9，之后再进行拥塞避免算法



#### 4.13 流量控制和拥塞控制的不同点

流量控制在于端到端的控制

拥塞控制是控制整个网络的拥塞程度



#### 4.14 UDP和TCP的对比

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\24.png" style="zoom:60%;" />

#### 4.15  TCP总结

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\b12.png" style="zoom:60%;" />

### 5.数据库

bcnf:所有属性完全依赖于码

存储过程

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\b13.png" style="zoom:60%;" />

**事务: 作为单个逻辑单元执行的一系列sql语句的集合，操作要么都执行，要么都不执行**
4个特性: ACID
原子性;要么都执行，要么都不执行事务是最小的工作单元，不可再分
一致性:数据库的完整性约束不能被破坏。
隔离性:并行执行的多个事务，多个事务互相不影响。
持久性:事务数据提交以后，持久的保存在数据库中。
语法: transaction
开启事务: start transaction;
一系列sq1语句;
提交: commit;
回滚: rollback;

### 6.Linux

#### 1.基本命令

**more**： 查看文本文件内容，屏幕显示完一屏就等待用户按下任意键再滚动到下一屏，如果中途不想继续看下去了，可以按ctrl c或q终止显示。

**less**：查看文本文件内容，屏幕显示完一屏就等待用户按键，用户可以向上或向下查看，如果中途不想继续看下去，可以按ctrl c或q终止显示。

**less好处:**不会留下查看痕迹

**head:** 显示指定文件的前面几行。如果没有指定文件，将从标准输入（键盘）上读取。如果没有指定要显示的行数，则默认显示前10行。如果要显示文件的前5行；

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux1.png" style="zoom:60%;" />

**tail:**显示文件的最后几行。若没有指定显示的行或字符数，则默认显示末尾10行。如果要显示文件末5行;

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux2.png" style="zoom:67%;" />

 **wc**: 利用wc指令我们可以计算文件的byte数，字数、或是列数，若不指定文件名称、或是所给予的文件名为”-”，则wc指令会从标准输入设备读取数据。

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux3.png" style="zoom:60%;" />

 **du** 查看某个目录的大小： 以M为单位

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux4.png" style="zoom:60%;" />

**df**:查看磁盘使用情况  

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux5.png" style="zoom:60%;" />

 **ln**

  链接有两种，一种被称为硬链接（Hard  Link），另一种被称为符号链接（Symbolic Link）.建立硬链接时，链接文件和被链接文件必须位于同一个文件系统中，并且不能建立指向目录的硬链接。而对符号链接，则不存在这个问题。默认情况下，ln产生硬链接。如果给ln命令加上-s选项，则建立符号链接。举例如下，注意ls  –l列出文件的硬链接数和字节数

硬链接是再创一个文件属性，硬链接计数器+1

符号链接也是创建文件属性，但是是通过原来文件属性间接找到那个文件内容，计数器不会+1

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux6.png" style="zoom: 50%;" />

**find**:根据文件名查找

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux7.png" style="zoom:60%;" />

**grep:**在文件里查找内容

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux8.png" style="zoom:60%;" />

**whoami**：查看当前登录用户 

**chmod:** 设置一个文件允许所有用户可读、可写、不可执行

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux9.png" style="zoom:60%;" />

 <img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux10.png" style="zoom:60%;" />

**chown**:更改某个文件或目录的属主和属组。

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux11.png" style="zoom:60%;" />

 **tar** [主选项+辅选项] 文件或者目录:

  tar可以为文件和目录创建档案。利用tar命令用户可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。使用该命令时，主选项是必须要有的，辅选项是辅助使用的，可以选用。

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux12.png" style="zoom:60%;" />

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux13.png" style="zoom:60%;" />

 **who** :查看当前在线上的用户情况。所有的选项都是可选的，不使用任何选项时，who命令将显示以下三项内容：

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux14.png" style="zoom:60%;" />

**ps**:命令用于监控后台进程的工作情况，因为后台进程是不和屏幕键盘这些标准输入/输出设备进行通信的，所以如果需要检测其情况，便可以使用ps命令了。

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux15.png" style="zoom:60%;" />

**jobs**:用来显示当前shell下正在运行哪些作业（即后台作业）。

**fg [job…]**:把指定的后台作业或挂起作业移到前台运行。

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux16.png" style="zoom:60%;" />

 **kill**:向指定进程发送信号

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux17.png" style="zoom:60%;" />

9号信号和15号信号的区别：对于sleeping状态的进程没区别，但是terminal状态9号杀死的更多，一般用九号

**env：**查看环境变量

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux18.png" style="zoom:40%;" />

**ifconfig**：查询网络配置

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux19.png" style="zoom:40%;" />

**netstat**：显示网络连接、路由表和网络接口信息，可以让用户得知目前都有哪些网络连接正在运作。

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux20.png" style="zoom:40%;" />

 **nslookup name** 查询一台机器的IP地址和其对应的域名。（有点像DNS域名解析协议）

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux21.png" style="zoom:60%;" />

  **finger [-lmsp] user [user@host…]**：查询用户的信息，通常会显示系统中某个用户的用户名、主目录、停滞时间、登录时间、登录shell等信息。

#### 2.编译和调试

**gcc：**当你使用默认的gcc，例如gcc main.c时会自动生成一个叫a.out的可执行文件

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux22.png" style="zoom:60%;" />

**如何运行可执行文件？**：./a.out  点斜杠加可执行文件名

**-o参数**：如果你不想要默认的可执行文件的名字，就加上-o参数，例如 gcc main.c -o myapp



```markdown
当你有多个头文件和多个.c文件的时候，头文件不用特殊处理但需要在同一路径下，而.c文件需要全进行编译例如：
```

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux23.png" style="zoom:60%;" />

**-I参数**：指定路径名，当你需要的头文件或者别的文件在别的路径下的时候需要指定，例如：

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux24.png" style="zoom:60%;" />

```markdown
gcc main.c add.c -I../include   //需要注意-I后面没有空格
```

**-Wall** 提示更多警告信息 

**-D参数:**编译时定义宏，注意-D和之间没有空格 如下

gcc main.c add.c -I../include -D_DEF_DEBUG -o myadd

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\linux25.png" style="zoom:60%;" />

### 7.项目

#### **7.01 项目流程**：

服务端先运行

客户端测试代码主函数，建立核心处理类对象，通过kernel对象的构造函数创建qt窗口，创建一个客户端中介者类对象，通过客户端中介者的构造就有了TcpClient类的对象，也传入了客户端中介者的对象，然后调用中介者类对象的openNet（）函数，这样就可以调用父类inet指针的initNet（）函数，就建立了连接，然后就可以通过客户端中介者类sendData函数发送数据，然后再调用父类里的TcpClient的sendData函数，就可以成功发送数据了。



然后服务端运行的时候，也会建立核心处理类的对象kernel，通过构造函数，就会初始化pKernel当前类指针（**静态指针，全局能用，为了到时候把数据发给核心处理的时候通过这个指针调用核心的dealData函数）**和服务端中介者类，有了服务端中介者类又会通过它的构造去创建TcpServer对象，然后继续回到主函数调用kernel对象的startServer函数，然后调用服务端中介者的openNet函数，再间接调用TcpServer的initNet（）函数，建立连接成功的时候就可以接收数据了，

其实如上就是服务端运行的时候做的一些初始化，有了这些才能接收数据

recvData，接收完之后把数据再传给中介者类，中介者类又会发送给核心处理类，然后核心处理类在打印收到的数据然后重新调用服务端中介者sendData发给客户端一个数据，客户端接收数据基本上就是同样的流程了



#### 7.1.准备阶段

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\项目1.png" style="zoom:60%;" />

**中介者类的作用：**当项目越来越大的时候，假如有五个类，五个类互发消息会有耦合，那么这个时候通过中介者类给他们派发消息就会作用明显

**如何实现udp和tcp两个协议的使用：**使用C++中的三个特性的一个：多态

**新建项目:**

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\项目2.png" style="zoom:60%;" />

```markdown
inet:文件作用
inet.h:父类，里面的函数必须是虚函数，只是提供一个api接口，实现多态
packDef.h:一些宏定义，避免魔鬼数字
TcpClient.h：client的类的一些成员变量和成员函数
TcpClient.cpp：client的函数实现
TcpServer.h：client的类的一些成员变量和成员函数
TcpServer.cpp：client的函数实现
UdpNet.h：udp的类的成员变量和函数
UdpNet.cpp：udp类的函数实现
```

#### 7.2代码实现

**inet.h:**

```c++
#pragma once
#include<iostream>
#include<Winsock2.h>
#pragma comment(lib,"Ws2_32.lib")
using namespace std;

class INet {
public:
	INet() {}
	virtual ~INet() {}//有多态的情况下父类的析构必须是虚析构


public:
	// 初始化网络
	virtual bool initNet() = 0;

	// 接收数据(暂时的)
	virtual void recvData() = 0;

	// 发送数据（TCP由socket决定发给谁，UDP由ip决定发给谁)
	// SOCKET是UINT类型，IP是ULONG类型，long类型两个都可以包括
	virtual bool sendData(char *data, int len, long to) = 0;

	// 关闭网络
	virtual void unInitNet() = 0;

};

```

TcpClient.h:

```c++
#include"inet.h"
#include"packDef.h"
#include<process.h>
class TcpClient:public INet {
public:
	TcpClient();
	~TcpClient();
public:
	bool initNet();

	void recvData();

	bool sendData(char* data, int len, long to);

	void unInitNet();
private:
	SOCKET m_sock;

	HANDLE m_handle;

	bool m_bStop = true;
private:
    //接收线程函数的声明，为什么是静态的呢，因为静态函数编译期及存在，不需要对象，不然还需要对象调用
	static unsigned __stdcall recvThread(void* lpVoid);
};
```

TcpClient.cpp:

**为什么不用createthread**：

<img src="D:\科林明伦三阶段\三阶段笔记内容截图\项目3.png" style="zoom:60%;" />

```c++
#include"TcpClient.h"

TcpClient::TcpClient():m_sock(INVALID_SOCKET),m_handle(NULL),m_bStop(false){

}
TcpClient::~TcpClient() {


}
unsigned __stdcall TcpClient::recvThread(void* lpVoid) {
    //普通指针肯定不好调用类成员函数，需要通过this指针，这样初始化参数的指针变成this指针类型就可以了
	TcpClient* const pThis = (TcpClient* const)lpVoid;
	pThis->recvData();
	return 1;

}

bool TcpClient::initNet(){
	// 1.加载库
	WORD wVersion = MAKEWORD(2, 2);
	WSAData data;
	int err = WSAStartup(wVersion, &data);
	if (err != 0) {
		cout << "WSAStartup error:" << err <<endl;
		return false;
	}
	if (HIBYTE(data.wVersion) != 2 || LOBYTE(data.wVersion) != 2) {
		cout << "WSAStart version error" << endl;
		WSACleanup();
		return false;
	}
	else {
		cout << "WSAStartup successs" << endl;
	}
	// 2.创建套接字
	m_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (m_sock == INVALID_SOCKET) {
		cout << "SOCKET error:" << WSAGetLastError() << endl;
		WSACleanup();
		return false;
	}
	else { cout << "socket success" << endl; }
	// 3.连接服务端
	struct sockaddr_in addrServer;
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(_DEF_TCP_PORT);
	addrServer.sin_addr.S_un.S_addr = inet_addr(_DEF_SERVER_IP);
	err = connect(m_sock, (sockaddr*)&addrServer,sizeof(addrServer));
	if (err == SOCKET_ERROR) {
		cout << "connect error:" << WSAGetLastError() << endl;
		closesocket(m_sock);
		WSACleanup();
		return false;
	}
	else { cout << "ip:" << inet_ntoa(addrServer.sin_addr) << endl; }

    //上面的三步和最开始写tcp的时候没什么不同，无非是错的时候不需要关闭套接字卸载库，返回false就行
	// 4.创建接收数据的线程

	m_handle = (HANDLE)_beginthreadex(0,0,&recvThread,(void*)this,0,NULL);
	//开始线程函数
	//为什么不用createthread见上面图片，这个函数参数第一个是安全函数，第二个栈大小，第三个就是绑定的线程函数（线程函数的地址），第四个就是传的参数，第五个是创建及运行，第六个是分配的线程ID，返回一个句柄
    

	return false;
}

void TcpClient::recvData(){
    //tcp有粘包问题
	int packSize = 0;//包大小
	int nRecvNum = 0;//接收长度
	int nOffset = 0;//偏移量（因为一个包可能会太大，一次发不完就需要偏移量）
	while (!m_bStop) {
		//先接收包大小
		nRecvNum = recv(m_sock, (char*)&packSize, sizeof(int), 0);
		if (nRecvNum > 0) {
			//new空间
			char* packBuf = new char[packSize];
			//再收包内容
			while(packSize>0){
				nRecvNum = recv(m_sock, packBuf + nOffset,packSize, 0);//这里的中间为什么是这样的因为，一个包太大了那么就会记录一下偏移量，用缓冲区大小加偏移，偏移量加上接收的大小
				if (nRecvNum > 0) {
					nOffset += nRecvNum;
					packSize -= nRecvNum;
				}
				else {
					cout << "recv error" << WSAGetLastError() << endl;
					break;
				}
			}

		}
		else {
			cout << "recv error:" << WSAGetLastError() << endl;
			break;
		}
	
	}
}

bool TcpClient::sendData(char* data, int len, long to){
	// 1.判断参数是否有效
	if (data == NULL || len <= 0) {
		cout << "parameter error" << endl;
		return false;
	}
	// 2.先发包大小
	if (send(m_sock, (char*)&len, sizeof(int), 0) <= 0) {
		cout << "send length error" << WSAGetLastError() << endl;
		return false;
	}
	// 3.再发包内容
	if (send(m_sock, data, len, 0) <= 0) {
		cout << "send data error" << WSAGetLastError() << endl;
		return false;
	}


	return false;
}

void TcpClient::unInitNet(){
	//回收线程:1、结束线程工作 2、关闭句柄
	m_bStop = true;
	if (m_handle) {
		if (WaitForSingleObject(m_handle, 500) == WAIT_TIMEOUT) {
			TerminateThread(m_handle,-1);
		}
		CloseHandle(m_handle);
	}

	//关闭套接字 、 卸载库
	if (m_sock && INVALID_SOCKET != m_sock) {
		closesocket(m_sock);
		WSACleanup();
	}
	
}
```

